Задача №1:
Два идентичных робота-клона на бесконечной прямой должны встретиться, имея между собой лишь одну уникальную метку (чёрную клетку). Решение — заставить эту метку работать как триггер, превращающий одного из роботов в "Охотника", который затем гарантированно находит второго, всё ещё предсказуемо блуждающего "Жертву".

Core Concept: Взлом Симметрии
Проблема не в навигации, а в симметрии. Если два агента имеют одинаковые программы и начинают в зеркальных условиях, они будут вечно двигаться зеркально. Ключ к решению — найти способ сломать эту симметрию, используя единственный уникальный элемент в их мире.

Чёрная клетка — это не просто точка на карте, это информационный катализатор. Программа использует её как "переключатель состояний". Робот, первым нашедший клетку, получает уникальный опыт, который не получает второй. Этот опыт мгновенно переводит его из режима ПОИСК в режим ПРЕСЛЕДОВАНИЕ.

Режим Поиска: Расширяющийся линейный поиск (1 вправо -> 2 влево -> 3 вправо...). Это детерминированный танец, гарантирующий исследование всей прямой.
Режим Преследования: Тупой, но эффективный спам команды ДВИГАТЬСЯ В ОДНОМ НАПРАВЛЕНИИ.
Как только один робот становится Охотником, встреча неизбежна, потому что его траектория становится простой прямой, в то время как Жертва всё ещё мечется по предсказуемой синусоиде.

Как это работает?
robot_simulator.py: Это наш "бог", симулятор мира. Он создаёт бесконечную ленту (в виде Python-координат), размещает на ней роботов и чёрную клетку, а затем тактирует время, заставляя роботов выполнять по одной команде за "секунду".
ROBOT_PROGRAM (внутри кода): Это прошитый в мозг роботов ассемблерный код. Из-за примитивности языка (ML, MR, IF, GOTO) циклы и сложные структуры реализованы через "развёртывание" — хардкодинг каждой фазы поиска с прямыми переходами GOTO. Строки 1-2 — это бесконечный цикл Охотника. Всё остальное — сложный танец Поиска.

Задача №2:
Три автомата, три лживые наклейки. Нужно узнать правду, купив одну жвачку. Стратегия: атаковать самое слабое звено — автомат с наклейкой «Красная и зелёная», потому что его ложь — самая предсказуемая.

Core Concept: Поиск Информационной Особенности
Это не головоломка, это задача на выявление точки с наименьшей неопределенностью. Все утверждения (наклейки) ложны, но они лгут по-разному.

Наклейка «Красная» может скрывать [Только зелёные] или [Смесь]. Две опции.
Наклейка «Зелёная» может скрывать [Только красные] или [Смесь]. Две опции.
Наклейка «Красная и зелёная» не может скрывать [Смесь]. Это аксиома задачи. Значит, она скрывает либо [Только красные], либо [Только зелёные].
Именно эта наклейка — информационный джекпот. Покупая жвачку из этого автомата, мы не просто получаем один бит информации (красная / зелёная), мы полностью снимаем неопределенность с этого автомата. Как только один элемент системы становится на 100% известным, остальные вычисляются по цепочке методом исключения. Это логический эффект домино, запущенный одним точным ударом.

Как это работает?
Скрипт gumball_solver.py — это не вычислитель, а симулятор логического вывода.

Он не пытается угадать. Он принимает на вход результат единственно верного действия: цвет жвачки из автомата «Красная и зелёная».
На основе этого входа он делает первый железный вывод: определяет истинное содержимое этого автомата.
Затем, используя методы исключения ("этот уже занят", "а этот не может быть таким по условию"), он дедуктивно определяет содержимое двух оставшихся автоматов.
Код по сути является исполняемым доказательством того, что стратегия работает для любого из двух возможных исходов (выпала красная или зелёная жвачка).

Задача №3: 
Скрипт подключается к API Центробанка РФ, брутфорсом выкачивает курсы валют за последние 90 дней и вычисляет максимум, минимум и среднее значение. Никакой магии, только методичная работа с данными.

Core Concept: Прагматичная Агрегация Данных
Эта задача — классический пример ETL (Extract, Transform, Load) в миниатюре. Её суть не в хитроумном алгоритме, а в аккуратной и отказоустойчивой обработке данных из внешнего, не всегда удобного источника.

Extract (Извлечение): Цикл по датам генерирует запросы к архаичному XML-API. requests выполняет грязную работу по общению с сервером. Встроен try-except для защиты от сетевых сбоев и нерабочих дней.
Transform (Преобразование): Самый важный шаг. Данные приходят в "сыром" виде.
Парсинг XML с помощью xml.etree.ElementTree.
Преобразование текстовых значений с запятой в числа с плавающей точкой.
Ключевая трансформация: Расчет реального курса Value / Nominal. Игнорирование этого шага даёт абсолютно неверные результаты, сравнивая курс 1 доллара с курсом 10 000 иранских риалов.
Load/Analyze (Загрузка/Анализ): Вместо загрузки в базу данных, мы агрегируем информацию на лету. Три простых переменных для max, min и две для average (sum и count) обновляются в цикле. Это эффективно по памяти и избавляет от необходимости хранить все 90 дней данных одновременно.
Программа — это цифровой археолог, который методично раскапывает 90 слоёв данных, очищает их от мусора и находит самые ценные и самые бесполезные артефакты, попутно вычисляя "среднюю температуру по больнице".

Как это работает?
cbr_analyzer.py: Единый скрипт, делающий всё.
Зависимости: Требует только библиотеку requests (pip install requests).
Процесс: Запускается, генерирует даты от "сегодня" до "90 дней назад", в цикле запрашивает XML для каждой даты, парсит его, корректирует курсы и обновляет итоговые показатели. В конце выводит отформатированный результат.